import numpy as np
import matplotlib.pyplot as plt
# from scipy.misc import imread
# from skimage.color import rgb2gray
# import skimage.io as skio
import skvideo.io as vidio
# import imageio as imio
import os
# from PIL import Image
from scipy.ndimage.morphology import binary_erosion as imerode
from scipy.signal import convolve2d as convolve2d


def read_image(filename):
    """
    :param filename: string containing the image filename to read
    :return: an image, represented by a matrix of type np.float64 with intensities (normalized to [0,1])
    """

    # first, let's read the image
    im = plt.imread(filename)

    # converting to float and normalizing to [0,1]
    im_float = im.astype(np.float64)
    im_float /= 255
    #
    # # if needed, converting to greyscale
    # if representation is 1:
    #     im_float = rgb2gray(im_float)

    return im_float


def __get_gaussian_kernel(kernel_size):
    """
    generates a gaussian kernel of size kernel_size X kernel_size using binomial coefficients
    :param kernel_size: size of wanted kernel
    :return: gaussian kernel matrix of size kernel_size X kernel_size
    """
    original_row = [[1, 1]]
    binomial_row = original_row.copy()
    for i in range(kernel_size - 2):
        binomial_row = convolve2d(binomial_row, original_row)

    kernel = convolve2d(binomial_row, np.transpose(binomial_row))
    kernel = kernel / np.sum(kernel)
    return kernel


def __blur_spatial(im, kernel_size):
    """
    performs image blurring using 2D convolution between image im and gaussian kernel g
    :param im: input image to be blurred
    :param kernel_size: size of the gaussian kernel in each dimension (odd)
    :return: blurry image
    """
    # getting gaussian kernel generated by binomial coefficients
    g = __get_gaussian_kernel(kernel_size)
    im_return = convolve2d(im, g, mode='same')
    return im_return


def apply_bw_effect_on_single_frame(orig_frame, mask):
    """
    applying the black and white effect on the given frame and mask
    :param orig_frame:
    :param mask_frame:
    :return: new frame after effect
    """
    overlay_color = [0, 0, 0]
    transparency = 0.6

    after_effect = orig_frame.copy()
    after_effect[:, :, 0] = mask * after_effect[:, :, 0] + (1 - mask) * (overlay_color[0]*transparency +
                                                                         (1-transparency)*after_effect[:,
                                                                                          :, 0])
    after_effect[:, :, 1] = mask * after_effect[:, :, 1] + (1 - mask) * (overlay_color[1]*transparency +
                                                                         (1-transparency)*after_effect[:,
                                                                                          :, 1])
    after_effect[:, :, 2] = mask * after_effect[:, :, 2] + (1 - mask) * (overlay_color[2]*transparency +
                                                                         (1-transparency)*after_effect[:,
                                                                                          :, 2])

    return after_effect


def apply_blur_effect_on_single_frame(orig_frame, mask):
    """
    applying the blur effect to the given frame and mask
    :param orig_frame:
    :param mask:
    :return:
    """
    after_effect = orig_frame.copy()
    eroded_mask = imerode(mask.copy(), structure=np.ones((20, 20)))
    after_effect[:, :, 0] = eroded_mask * after_effect[:, :, 0] + (1 - eroded_mask) * __blur_spatial(
        after_effect[:, :, 0], 7)
    after_effect[:, :, 1] = eroded_mask * after_effect[:, :, 1] + (1 - eroded_mask) * __blur_spatial(
        after_effect[:, :, 1], 7)
    after_effect[:, :, 2] = eroded_mask * after_effect[:, :, 2] + (1 - eroded_mask) * __blur_spatial(
        after_effect[:, :, 2], 7)
    plt.figure()
    plt.imshow(after_effect)
    plt.show()
    return after_effect


def apply_blur_bw_on_single_frame(orig_frame, mask):
    """
    applying the blur effect to the given frame and mask, also coloring background black and white
    :param orig_frane:
    :param mask:
    :return:
    """
    after_effect = apply_bw_effect_on_single_frame(orig_frame, mask)
    after_effect = apply_blur_effect_on_single_frame(after_effect, mask)
    return after_effect


if __name__ == '__main__':
    # filename = './images/Wildlife.mp4'
    # vid = vidio.vread(filename)
    # print(vid.shape)
    # vid = imio.get_reader(filename, 'ffmpeg')
    # metadata = vid.get_meta_data()
    # print(metadata)
    # print('hi')

    orig_path = './images/orig frames/'
    orig_frames_paths = [os.path.join(orig_path, curr_frame) for curr_frame in sorted(os.listdir(orig_path))]
    masks_path = './images/masks/'
    mask_frames_paths = [os.path.join(masks_path, curr_frame) for curr_frame in sorted(os.listdir(masks_path))]
    # # print(orig_frames_paths)
    # image = Image.open(orig_frames_paths[1])
    image = read_image(orig_frames_paths[1])
    # plt.figure()
    # plt.imshow(image)
    # plt.show()

    # im = plt.imread('./images/IMG1.jpg')
    # plt.figure()
    # plt.imshow(im)
    # plt.show()

    mask = read_image(mask_frames_paths[1]) * 255
    # after_image = apply_bw_effect_on_single_frame(image, mask)
    # plt.figure()
    # plt.subplot('131')
    # plt.imshow(image)
    # plt.subplot('132')
    # plt.imshow(mask, cmap='gray')
    # plt.subplot('133')
    # plt.imshow(after_image)
    # plt.show()

    after_image = apply_blur_bw_on_single_frame(image, mask)
    plt.figure()
    plt.subplot('131')
    plt.imshow(image)
    plt.subplot('132')
    plt.imshow(mask, cmap='gray')
    plt.subplot('133')
    plt.imshow(after_image)
    plt.show()